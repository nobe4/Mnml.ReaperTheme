; vim: foldmethod=indent syntax=lisp

; Documentation
; front specify the z index of elements

; Global variables
	; Reaper-defined
		version 6.0
		use_pngs 1
		tcp_showborders 0
		mcp_showborders 0
		transport_showborders 0
		tcp_vupeakwidth 2
		mcp_vupeakheight 2
		mcp_mastervupeakheight 4
		mcp_altmeterpos 0
		use_overlays 1
		tcp_vol_zeroline FF666666
		tcp_pan_zeroline 66000000
		mcp_vol_zeroline FF666666
		mcp_pan_zeroline 85000000
		trans_speed_zeroline 85000000
		gen_vol_zeroline FF000000
		gen_pan_zeroline FF000000
		item_volknobfg 85000000 FF778485 00474F4F
		mcp_min_height 240
		tcp_master_minheight 56
		mcp_voltext_flags 5 5
		tcp_voltext_flags 12
		tinttcp 298
		peaksedges 0
		no_meter_reclbl 1
		tcp_heights 2 20 20 20   ; supercollapsed, collapsed, small(norecarm), recarm size
		tcp_folderindent 0
		envcp_min_height 27
		misc_dpi_translate 134 150
		misc_dpi_translate 174 200

	; Font Settings
		; font #1/6/11 - calibri 8
		; font #2/7/12 - calibri 9
		; font #3/8/13 - calibri 10
		; font #4/9/14 - calibri 11

	; Global text colors settings
		set custom_col [trackcolor_r trackcolor_g trackcolor_b]
		set luma + + * 0.299 [trackcolor_r] * 0.587 [trackcolor_g] * 0.114 [trackcolor_b]

		; macro for the color of text that is drawn over custom colors
		set swapLuma 130 ; (0 to 255) custom color brightness to switch from 'light' to 'dark' text
		set pushLuma 90 ; (0 to 255) very dim custom color brighness

	; TCP
		set tcp_folder_width [0 0 20 0]  ; Folder vertical width
		set tcp_folder_indent 2          ; Px to indent a folder by
		set tcp_control_align 1          ; Align the control regardless of a folder
		set tcp_row_height 20            ; Height of a TCP row
		set tcp_min_width tcp_row_height ; Min width of a row is its height
		set tcp_min_label_width 180      ; Minimum size for the tcp label
		set tcp_main_collapse_width 200  ; Min witdh before main section collapses

; Macros
	; Reset all the hide settings
		macro resetHides
			set hide_tcp.recarm   0
			set hide_tcp.recmon   0
			set hide_tcp.label    0
			set hide_tcp.volume   0
			set hide_tcp.io       0
			set hide_fx_group     0
			set hide_tcp.env      0
			set hide_pan_group    0
			set hide_tcp.recmode  0
			set hide_input_group  0
			set hide_values       0
			set hide_meter_values 0
		endMacro

	; Compute all the variables to draw the tcp later
		macro compute_tcp_sections
			; Dynamic elements
				; tcp_supercollapsed is whether the parent height is too small for the tcp section
				set tcp_supercollapsed h<10 1 0

				; Invert position of meter if the tcp is on the right.
				set meter_right tcp_meter_position{0} < 2 tcp_meter_position{0} ?recarm 0 1

			; Label
				set tcp_LabelAutoMesure \
					tcpLabelAutoMeasured{0}<tcp_min_label_width \
						tcp_min_label_width \
						+ tcpLabelAutoMeasured{0}

				; Effective label size
				set tcp_label_size \
					tcp_LabelPair{0}==0 \
						tcp_LabelAutoMesure \
						tcp_LabelPair

				; Label is the track name
				set tcp_label_end + tcp_label_size{0} 54

			; Indent
				set this_tcp_indent * tcp_folder_indent folderdepth{0}

				set folder_section \
					+ tcp_folder_width \
						* [0 0 1] \
							* tcp_folder_indent{0} \
							? tcp_control_align{0} \
								maxfolderdepth{0} \
								folderdepth{0}

			; Main section
				; Between the folder and the meter, contains the buttons and label.
				set main_section_width - - w folder_section{2} tcp_meter_size{2}
				; If the tcp is on the right, we need to add the meter's size to the x, as it's displayed before.
				set main_section_x + folder_section{2} !meter_right{0} tcp_meter_size{2} 0
				set main_section [main_section_x 0 main_section_width h]

				; Is the label vertical or not: the main section is shorter than the label size.
				set tcp_label_vertical main_section{2}<tcp_label_end{0} 1 0

				; collapse main_section to enough for a flipped label if its too small to be useful, then scale meter to fill the gap
				set main_section_narrow main_section{2}<tcp_main_collapse_width{0} 1 0

				; Reduce main_section if label is flipped
					; TODO: redo this, works but not great
					set main_section \
						?tcp_supercollapsed{0} [0] \
						?main_section_narrow{0} \
							?meter_right{0} \
								[folder_section{2} 0 tcp_row_height h] \
								- [w 0 tcp_row_height h] [tcp_row_height] \
								?tcp_label_vertical{0} \
									- main_section [0 0 tcp_row_height] \
									main_section

				; Effective width of main_section, used to determine row width.
				; Basically 0 if the section is narrowed, otherwise its width minus 5 to wrap without overlap
				set main_size ?main_section_narrow{0} 0 - main_section{2} 5

			; Meter
				; Meter section is the position/size of the meter: location of the folder
				; with the width of the meter.
				set meter_section + [folder_section{2} 0 0 h] [0 0 tcp_meter_size{0}]
				set meter_section ?meter_right{0} - [w 0 meter_section meter_section] [meter_section{2}]

				; Update for the collapsed/narrow situations, simiar to main section above.
				; Same TODO
				set meter_section \
					?tcp_supercollapsed{0} [0] \
					?main_section_narrow{0} \
						?meter_right{0} \
							- + [main_section 0 w h] [main_section{2} 0] \
								+ [0 0 main_section{0}] [0 0 main_section] \
							- - [folder_section{2} 0 w h] [0 0 folder_section] \
								[0 0 10]

			; Minimal tcp size
			set tcp.size + [300 100] [0 0 tcp_min_width{0}]

			set tcp_label_size ?tcp_label_vertical{0} [0] ; not included in mainsec calculations if flipped

			; First element to build from is the main section
			set previous_element [main_section]
		endMacro

	; Compute all the variables to draw the master tcp later
		macro calcMasterTcpSecs
			set tcp_row_height 							 20
			set tcp_MeterSize_s						 tcp_meter_size
			set mTcp_PanSize							trackpanmode==3 20 43
			set meter_flip_v						 [100 130 183] 	;[narrow_width flip_height flip_height(narrow)]
			set meter_flip								w>meter_flip_v{0} h<meter_flip_v{1} [1] [0] h<meter_flip_v{2} [1] [0]
			set meter_right								tcp_meter_position{0}
			set meter_section								!meter_flip{0} [0] !meter_right{0} \
														 + [0 4 50 -1] [0 0 tcp_MeterSize_s h] \
															+ - + [-33 0 33] [0 0 tcp_MeterSize_s h] [tcp_MeterSize_s] [w]
			set vol_sec									!meter_flip{0} [0] !meter_right{0} \
															+ - [meter_section{2} h w] [0 0 meter_section{2}] [3 -20 -2 21] \
															- + [0 h w] [0 -22 -3 22] [0 0 meter_section{2}]
			set main_section								?meter_flip{0} \
															!meter_right{0} \
																- - - [meter_section{2} 0 w h] [0 6] [0 0 meter_section{2}] [0 0 0 vol_sec] \
																- - [0 0 w h] [6 6] [0 0 meter_section{2} vol_sec] \
															- - [0 0 w h] [0 6] [0 0 0 meter_section]
			set main_size								main_section{2}
			set mainCollapse_h						 64
			set main_section_narrow							main_section{2}<mainCollapse_h{0} 1 0
			set tcpNullElement							+ + [main_section main_section] [0 6 0 20]
			set previous_element 						tcpNullElement
		endMacro

	; Draw the master tcp
		macro draw_master_tcp
			set master.tcp.size						 [300 100 40 56]
			set main_section								!meter_flip{0} + [0 0 0 this_y_end{0}] [0 0 0 8]  ; recalculate sections now we know this_y_end
			set vol_sec									!meter_flip{0} + [0 main_section{3} w 0] [0 0 0 22] .
			set meter_section								?main_section_narrow{0} [0 0 w h] !meter_flip{0} tcp_fxparms>0 \
																											+ [0 vol_sec w 70] [0 vol_sec{3}] \
																											- - + [0 vol_sec w h] [0 vol_sec{3}] [0 0 0 main_section] [0 0 0 vol_sec]
			set master.tcp.meter                   		- - + meter_section [5 2 -5 -5] [0 0 tcp.mute{2}] [0 0 0]
				set master.tcp.meter.vu.div                    [1]
				set master.tcp.meter.readout.color             [100 100 100 255 255 183 171 255]
				set master.tcp.meter.scale.color.lit.bottom    [0 0 0 200 0 0 0 0]
				set master.tcp.meter.scale.color.lit.top       [0 0 0 200 0 0 0 0]
				set master.tcp.meter.scale.color.unlit.bottom  [255 255 255 120 0 0 0 0]
				set master.tcp.meter.scale.color.unlit.top     [255 255 255 120 0 0 0 0]
			;set master.tcp.mute               			+ + [meter_section meter_section] [meter_section{2}] [-25 4 21 20]
			;set master.tcp.solo 						+ + [0 2] master.tcp.mute [0 master.tcp.mute{3}]
			set master.tcp.label.color					tcp.label.color
			set master.tcp.label.font					[3]
			set master.tcp.fx 							!master_fx_group{2} [0] + [0 0 20] [master_fx_group master_fx_group 0 tcp_row_height]
			set master.tcp.fxbyp 						!master_fx_group{2} [0] + + [0 0 16] [master.tcp.fx master.tcp.fx 0 tcp_row_height] [master.tcp.fx{2}]
			set master.tcp.pan 							!master_pan_group{2} [0 0 0 0] trackpanmode==6 \
															* [master_pan_group master_pan_group master_pan_group master_pan_group tcp_row_height] [1 1 1 0.5] \
															[master_pan_group master_pan_group tcp_row_height tcp_row_height] ; knobs have the same h and w
				set master.tcp.pan.fadermode         	gl_fader_swap
				set master.tcp.pan.color              	gl_pan_color
			set master.tcp.width						trackpanmode==3 [0] !master_pan_group{2} [0 0 0 0] trackpanmode==6 \
															+ [master.tcp.pan master.tcp.pan master.tcp.pan master.tcp.pan] [0 master.tcp.pan{3}] \
															- + [master_pan_group master_pan_group tcp_row_height tcp_row_height] [master_pan_group{2}] [tcp_row_height]
				set master.tcp.width.fadermode        	gl_fader_swap
				set master.tcp.width.color            	gl_pan_color
			set main_val_color							?track_selected [160 160 160] [115 115 115]
			set master.tcp.fxparm  						- + [0 meter_section w h] [0 meter_section{3}] + [0 0 0 meter_section{1}] [0 0 0 meter_section{3}]
			set master.tcp.fxparm.margin			 [3 0 3 0 0 14]
		endMacro

	; Apply hide on elements depending on settings
		macro doHideLogic element paramIdx
			set hide_##element param##paramIdx##&1 ?mixer_visible 1 0
			set hide_##element param##paramIdx##&2 !track_selected 1 hide_##element
			set hide_##element param##paramIdx##&4 !recarm 1 hide_##element
			set hide_##element param##paramIdx##&8 1 hide_##element
		endmacro

	; Then macro to handle elements one after the other
		macro then element element_width
			; Previous end is the previous element position + width
			set prev_end + previous_element{0} previous_element{2}

			; Place the current element at the previous end, save width and height
			set element [prev_end previous_element element_width tcp_row_height]

			; if hidden, set width to 0
			set element ?hide_##element{0} [. . 0 tcp_row_height]

			; Compute current element rightmost point: it's position + width, minus
			; the main section position.
			set element_rightmost - + element{0} element{2} main_section{0}

			; If collapsed, change the width and height to 0 0
			set element ?main_section_narrow{0} [. . 0 0]

			; Get top of next row
			set next_row + [0 previous_element{3}] [0 element]

			; If element overflows, move to next row
			set element element_rightmost{0}>main_size{0} [main_section next_row element element]
		
			; Recalculate element_rightmost, now that the element is on a new row
			set element_rightmost - + element{0} element{2} main_section{0}

			; Remove if still not fitting
			set element element_rightmost{0}>main_size{0} [. . 0 0]
			
			; Find its bottom: top + height
			set this_y_end + element{1} element{3}

			; Cull if there's not enough height to fit, or if previous_element was culled;
			set element this_y_end{0}>main_section{3} [. . 0 0] .

			; Save reference to previous element
			set previous_element element

			; save reference to main last visible element
			set main_section_last_visible_element element{3}>0 this_y_end{0} .
		endmacro

	; Draw the tcp section
		macro draw_tcp
			; Track id
				set tcp.trackidx + + [0 0 this_tcp_indent] [folder_section 0 0 0 0 0 0 1] [0 0 18 100]
				; if collapsed, add to the current track some height to hide the text
				set tcp.trackidx ?tcp_supercollapsed{0} + tcp.trackidx [0 0 0 40]

				; vertical margin for track number
				set tcp_idx_margin - / h 2 18
				set tcp.trackidx.margin + [this_tcp_indent] + [0 tcp_idx_margin 0 tcp_idx_margin 0.5] folderstate<0 [0 -6 0 6] folderstate==1 [0 16] 0

				; font
				set tcp.trackidx.font [2]

				; color
				text_over_custom tcp.trackidx.color
				set tcp.trackidx.color ?track_selected [50 50 50]

			; Folders
				; folder compact button
					set tcp.foldercomp \
						?tcp_supercollapsed{0} [0] \
							+ \
								+ [this_tcp_indent] [folder_section] \
							 [0 0 18 19]

				; folder button
					set tcp.folder \
						?tcp_supercollapsed{0} \
							[0] \
							+ [this_tcp_indent] \
								[folder_section 86 18 14 0 1 0 1]
				
				; If folder min size and not last one, hide button
					set tcp.folder \
						h<32 \
							folderstate<0 . [0] \
							.

			; Meter view: the meter section wit
					set tcp.meter meter_section  ; set size
					set tcp.meter.vu.div [1] ; show divisions

				; meter text color
					; Top value, always visible    non clipped     clipped
						set tcp.meter.readout.color [100 100 100 255 255 0 0 255]
					; meter scale bottom and top color for unlit (no sound) and lit (sound)
					; Don't display anything for unlit, and a grey for lit.
						set tcp.meter.scale.color.unlit.bottom [0]
						set tcp.meter.scale.color.unlit.top tcp.meter.scale.color.unlit.bottom
						set tcp.meter.scale.color.lit.bottom [100 100 100 255]
						set tcp.meter.scale.color.lit.top tcp.meter.scale.color.lit.bottom

			; Flip label if vertical for condensed vue
				set tcp.label ?tcp_label_vertical{0} + [main_section 0 1 -2] [main_size{0} 0 tcp_row_height h]
				; If vertical, align horizontally and vertically, otherwise, only vertically.
				set tcp_label_horizontal_align ?tcp_label_vertical 0.5 0
				set tcp.label.margin [1 1 1 1 tcp_label_horizontal_align 0.5]
				; Dynamic coloring
				track_label_color tcp.label.color

			; Buttons
				; Fx
					; Add fx button at its position, fixing width to 20.
					set tcp.fx !fx_group{2} [0] [fx_group fx_group 20 tcp_row_height]

					; Fx bypass button, after fx button, width of 16
					set tcp_fxbyp_x + tcp.fx{0} tcp.fx{2}
					set tcp.fxbyp !fx_group{2} [0] [tcp_fxbyp_x tcp.fx 16 tcp_row_height]

				; Fx input, with padding for button.
					set tcp.fxin !input_group{2} [0] [input_group input_group 29 tcp_row_height]
					; Text item is larger and has reduced width for the button.
					set tcp.recinput - + [tcp.fxin{2}] [tcp.fxin tcp.fxin input_group tcp_row_height] [0 0 tcp.fxin{2}]
					; Margin right 20 is to prevent overlap with the icon.
					set tcp.recinput.margin [0 0 20 0 0.5]
					set tcp.recinput.font [1]

				; Fx and record input, with padding for button

				; Volume
					set tcp.volume [tcp.volume tcp.volume tcp.volume tcp_row_height]
					set tcp.volume.fadermode 1

				; Pan
					set tcp.pan [tcp.pan tcp.pan tcp.pan tcp_row_height]
					set tcp.pan.fadermode 1

				; Width
					set tcp.width [tcp.width tcp.width tcp.width tcp_row_height]
					set tcp.width.fadermode 1

			; Fx parameter controls list
				set tcp.fxparm  [main_section main_section_last_visible_element{0} main_section main_section]
				set tcp.fxparm.font [1]
				set tcp.fxparm.margin [0]
		endMacro

	; Mixer
		macro drawMcp
			; Define variables
				set hide_inputFX_s      hide_inputFX
				set hide_input_s        hide_input
				set hide_pan_labels_s   hide_pan_labels
				set hide_pan_s          hide_pan
				set hide_volume_label_s hide_volume_label
				set extmixer_w_s        extmixer_w

				set mcp_indent_s   mcp_indent
				set mcp_meterExp_s mcp_meterExp

				set mcp_meterExp_s ?meterExpMode{0} . 1
				set panLabelsMode h<hide_pan_labels_s{x} 0 labelsMode
				; burp
				set gapmode \
					mcp_border{0}<1 \
						0 \
						mcp_border{0}==1 \
							1 \
							mcp_border{0}==2 \
								2 \
								mcp_border{0}==3 \
									folderstate==1 \
										folderdepth==0 \
											1 \
											0 \
										folderstate<0 \
											folderdepth==1 \
												2 \
												0 \
											0 \
											folderstate==1 \
												1 \
												folderstate<0 \
													2 \
													0

			set nchan_offs ?meterExpMode{0} * - tracknch 2 mcp_meterExp_s [0]
			set nchan_offs_half / nchan_offs 2
			set nchan_offs_third / nchan_offs 3
			set nchan_offs_twothird * nchan_offs_third 2

			clear mcp.*

			; Put some elements to the front
			front mcp.label mcp.volume.label mcp.volume mcp.recarm mcp.recmon mcp.mute mcp.solo mcp.env mcp.io mcp.phase mcp.width mcp.trackidx mcp.folder

			; Burp: TODO
				set mcp.size + + \
					+ ?narrowMode{0} \
				 [54 371] \
				 [86 371] \
					mcp_meterExp_s{0}>0 [nchan_offs{0}] [0] \
					+ gapmode{0}>=1 [14] [0] \
					!sidebarMode{0} [0] [extmixer_w_s] \
					* [0 0 0 1] + 180 * mcp_maxfolderdepth mcp_indent_s ; set the min height

			; More variables, depending on the mcp size
				set sidebar_sec + gapmode{0}>=1 gapmode{0}!=2 [0 0 14] [0] [0] !sidebarMode{0} [0] [0 0 extmixer_w_s{0}]
				set fx_sec + [sidebar_sec{2} 0 mcp.size{0}] [0 0 0 33]
				set pan_sec + [sidebar_sec{2} fx_sec{3} mcp.size{0}] !panLabelsMode{0} h<hide_pan_s{0} [0 0 0 6] [0 0 0 28] [0 0 0 48]
				set in_sec + + [sidebar_sec{2} pan_sec{1}] [0 pan_sec{3} mcp.size{0}] h<hide_input_s{0} [0 0 0 22] h<hide_inputFX_s{0} [0 0 0 42] [0 0 0 54]
				set bot_sec_height ?mcp_control_align{0} \
					+ 47 * mcp_maxfolderdepth mcp_indent_s \
					+ 47 * folderdepth mcp_indent_s
				set bot_sec - [0 h mcp.size{0} bot_sec_height{0}] [0 bot_sec_height{0}]
				set stretch_sec_start + + fx_sec{3} pan_sec{3} in_sec{3}
				set stretch_sec_height - - - - h fx_sec{3} pan_sec{3} in_sec{3} bot_sec{3}
				set stretch_sec [sidebar_sec{2} stretch_sec_start{0} mcp.size{0} stretch_sec_height{0}]
				set sidebar_sec + + + sidebar_sec [0 0 0 stretch_sec{1}] [0 0 0 stretch_sec{3}] [0 0 0 1]
				set padding_reduction_h [300 200]
				set padding stretch_sec_height{0}<padding_reduction_h{0} stretch_sec_height{0}<padding_reduction_h{1} [0 2] [0 3] [0 4]

			set mcp.extmixer.mode !sidebarMode{0} [0] [1]
			set mcp.extmixer.position + + sidebar_sec + [1 0 1] [0 2 0 -2] gapmode{0}>=1 gapmode{0}!=2 [13 0 -13] [0] [0]
			set mcp.fxlist.font [1 16]
			set mcp.fxlist.margin  [4 0 4 0 0.5 14]
			set mcp.sendlist.font [1 16]
			set mcp.sendlist.margin [4 0 4 0 0 0 14]
			set mcp.fxparm.font [1 24 0 0 -1]
			set mcp.fxparm.margin [2 0 4 0 0 14]
			set mcp.fx + [fx_sec 0 nchan_offs_twothird{0}] ?narrowMode{0} [4 7 28 20] [7 7 43 20]
			set mcp.fxbyp + + [mcp.fx mcp.fx nchan_offs_third{0}] [mcp.fx{2}] ?narrowMode{0} [0 0 19 20] [0 0 29 20]

			set mcp.pan ?narrowMode{0} \
				h<hide_pan_s{0} [0] + [pan_sec pan_sec] trackpanmode==6 + [0 0 nchan_offs{0}] !panLabelsMode{0} [3 6 48 9] [3 15 48 9] \
				trackpanmode>=4 + [nchan_offs_third{0}] !panLabelsMode{0} [28 4 20 20] [26 7 20 20] \
				+ [nchan_offs_half{0}] !panLabelsMode{0} [18 4 20 20] [18 7 20 20] \
				h<hide_pan_s{0} [0] + [pan_sec pan_sec] trackpanmode==6 + [0 0 nchan_offs{0}] !panLabelsMode{0} [7 6 73 9] [7 15 73 9] \
				trackpanmode>=4 + [nchan_offs_third{0}] !panLabelsMode{0} [20 4 20 20] [20 7 20 20] \
				+ [nchan_offs_half{0}] !panLabelsMode{0} [33 4 20 20] [33 7 20 20]
			set mcp.pan.fadermode gl_fader_swap
			set mcp.pan.color gl_pan_color
			set mcp.pan.label ?narrowMode{0} \
				!panLabelsMode{0} [0] + [pan_sec mcp.pan] trackpanmode>=4 trackpanmode==6 + [nchan_offs_half{0}] [11 -11 35 9] + [nchan_offs_half{0}] h<hide_input_s{0} [0] [17 25 35 10] + [nchan_offs_half{0}] [10 25 35 10] \
				!panLabelsMode{0} [0] + [pan_sec mcp.pan] trackpanmode>=4 trackpanmode==6 + [nchan_offs_half{0}] [23 -11 40 9] + [nchan_offs_third{0}] [8 25 35 10] + [nchan_offs_half{0}] [26 25 35 10]
			set mcp.pan.label.color val_color
			set mcp.pan.label.font [1]
			set mcp.pan.label.margin [0 0 0 0 0.5]
			set mcp.width ?narrowMode{0} \
				h<hide_pan_s{0} [0] + [pan_sec pan_sec] trackpanmode==6 + [0 0 nchan_offs{0}] !panLabelsMode{0} [3 14 48 9] [3 23 48 9] \
				trackpanmode>=4 + [nchan_offs_third{0}] + [nchan_offs_third{0}] !panLabelsMode{0} [7 20 20 20] h<hide_input{0} [9 31 20 20] [9 46 20 20] [0] \
				h<hide_pan_s{0} [0] + [pan_sec pan_sec] trackpanmode==6 + [0 0 nchan_offs{0}] !panLabelsMode{0} [7 14 73 9] [7 23 73 9] \
				trackpanmode>=4 + [nchan_offs_third{0}] + [nchan_offs_third{0}] !panLabelsMode{0} [48 4 20 20] [48 7 20 20] [0]
			set mcp.width.fadermode gl_fader_swap
			set mcp.width.color gl_width_color
			set mcp.width.label ?narrowMode{0} \
				!panLabelsMode{0} [0] + [0 mcp.width] trackpanmode>=4 trackpanmode==6 + [mcp.pan.label] [0 11 35 9] h<hide_inputFX_s{0} [0] [3 25 35 9] [0] \
				!panLabelsMode{0} [0] + [0 mcp.width] trackpanmode>=4 trackpanmode==6 + [mcp.pan.label] [0 11 40 9] + [nchan_offs_third{0}] + [-5 25 35 10] [mcp.width] [0]
			set mcp.width.label.color val_color
			set mcp.width.label.font [1]
			set mcp.width.label.margin [0 0 0 0 0.5]
			set mcp.recinput h<hide_input_s{0} [0] + [in_sec in_sec nchan_offs{0}] ?narrowMode{0} trackpanmode==5 [0] [6 0 43 16] [6 0 75 16]
			set mcp.recinput.color ?track_selected [225 225 225] [200 200 200]
			set mcp.recinput.font [1]
			set mcp.recinput.margin [4 0 15 0 0]
			set mcp.fxin ?narrowMode{0} [0] h<hide_inputFX_s{0} [0] + [mcp.recinput mcp.recinput] + [nchan_offs{0}] [0 16 75 12]
			set mcp.recmode ?narrowMode{0} [0] + + [in_sec in_sec nchan_offs{0}] [0 mcp.fxin{3}] + [6 4 41 16] mcp.recinput{3}>0 [0 16] [0 -4]
			set mcp.meter ?narrowMode{0} + [4 4 20 -31] [stretch_sec stretch_sec nchan_offs{0} stretch_sec] \
				+ [stretch_sec stretch_sec nchan_offs{0} stretch_sec] h<hide_volume_label_s{0} [4 4 20 -4] !labelsMode{0} [4 4 20 -4] [4 23 20 -23]
			set mcp.meter.vu.div [1 1]
			set mcp.meter.readout.color !labelsMode{0} [0 0 0 0 0 0 0 0] [100 100 100 255 255 183 171 255]
			set mcp.meter.scale.color.lit.bottom !labelsMode{0} [0 0 0 0 0 0 0 0] [0 0 0 170 0 0 0 0]
			set mcp.meter.scale.color.lit.top !labelsMode{0} [0 0 0 0 0 0 0 0] [0 0 0 170 0 0 0 0]
			set mcp.meter.scale.color.unlit.bottom !labelsMode{0} [0 0 0 0 0 0 0 0] ?recarm [255 64 0 255 0 0 0 0] [255 255 255 60 0 0 0 0]
			set mcp.meter.scale.color.unlit.top !labelsMode{0} [0 0 0 0 0 0 0 0] ?recarm [255 64 0 255 0 0 0 0] [255 255 255 60 0 0 0 0]
			set mcp.volume.label ?narrowMode{0} [0] \
				+ [stretch_sec stretch_sec mcp.meter{2}] h<hide_volume_label_s{0} [1 0 28 4] !labelsMode{0} [1 0 28 4] [1 0 28 23]
				; + h<hide_volume_label_s{0} [1 0 28 4] !labelsMode{0} [1 0 28 4] [1 0 28 23] [stretch_sec stretch_sec mcp.meter{2}]
			set mcp.volume ?narrowMode{0} + - + [stretch_sec stretch_sec] [nchan_offs_half stretch_sec{3}] [-4 21] [0 0 21 21] \
				- + [mcp.meter stretch_sec 21 stretch_sec] [mcp.meter{2} mcp.volume.label{3}] [-4 0 0 mcp.volume.label{3}]
			set mcp.volume.label.color mcp.volume.label{h}>2 [100 100 100] [38 38 38]
			set mcp.volume.label.font [1]
			set mcp.volume.label.margin ?narrowMode{0} [0 80 0 0 0.5] [0 4 0 0 0.5]
			set mcp.recarm + [0 0 36 24] ?narrowMode{0} - + [mcp.meter{2}] [stretch_sec stretch_sec] [-1 17] \
				+ - [stretch_sec stretch_sec] [-29 17] [mcp.meter{2}]
			set mcp.recmon + + [0 padding] [mcp.recarm mcp.recarm] [7 20 21 20]
			set mcp.mute + + [0 padding] [mcp.recmon mcp.recmon] [0 19 21 20]
			set mcp.solo + + [0 padding] [mcp.mute mcp.mute] [0 21 21 20]
			set mcp_io_hide_h 106
			set mcp.io stretch_sec_height{0}<mcp_io_hide_h{0} [0] + + [0 padding] [mcp.solo mcp.solo] !labelsMode{0} [-1 23 23 22] [-1 23 23 30]
			set mcp_env_hide_h [125 141]
			set mcpHideEnv !labelsMode{0} stretch_sec_height{0}<mcp_env_hide_h{0} 1 0 stretch_sec_height{0}<mcp_env_hide_h{1} 1 0
			set mcp.env ?mcpHideEnv{0} [0 0 0 0] + [0 stretch_sec{3}] + [mcp.io stretch_sec] !labelsMode{0} [1 -22 21 22] [1 -30 21 30]
			set mcp_phase_hide_h [144 162]
			set mcpHidePhase !labelsMode{0} stretch_sec_height{0}<mcp_phase_hide_h{0} 1 0 stretch_sec_height{0}<mcp_phase_hide_h{1} 1 0
			set mcp.phase ?mcpHidePhase{0} [0] + [mcp.env mcp.env] - [3 -18 16 18] padding
			set mcp.label + + + \
				gapmode{0}==1 !sidebarMode{0} [14 0 -14 27] [13 0 -13 27] \
				gapmode{0}==2 [0 0 -14 27] \
				[0 0 0 27] \
				[0 bot_sec mcp.size{0}] \
				?mcp_control_align{0} * - mcp_maxfolderdepth folderdepth [0 0 0 mcp_indent_s{0}] [0]
			set mcp.label.margin [4 0 4 3 0.5]
			set mcp.label.font [3]
			track_label_color mcp.label.color
			set mcp.trackidx + + [0 bot_sec] [0 mcp.label{3}] - [0 0 mcp.size{0} bot_sec_height{0}] [0 0 0 mcp.label{3}]
			set mcp.trackidx.margin + - [0 0 0 mcp.trackidx{3} 0.5] [0 0 0 20] folderstate==1 [12] [0]
			text_over_custom mcp.trackidx.color
			set mcp.trackidx.color ?track_selected [50 50 50] .
			set mcp.trackidx.font [3]
			set mcp.folder + + [0 bot_sec] [0 mcp.label{3}] folderstate<0 + + [mcp.size] [sidebar_sec{2}] [-21 -2 21 22] [0 -2 18 22]
		endMacro

	; Create parameters
		macro indexParams desc val min max idx
			define_parameter param##idx desc val min max
		endmacro

	; Set custom color over background
		macro text_over_custom element
			set element \
				?trackcolor_valid \
					?track_selected \
						+ custom_col \
							luma{0}<swapLuma{0} \
								luma{0}<pushLuma \
									[220 220 220] \
									[-100 -100 -100] \
									[-120 -120 -120] \
						+ custom_col \
							luma{0}<swapLuma{0} \
								luma{0}<pushLuma
									[180 180 180] \
									[100 100 100] \
									[-120 -120 -120] \
					?track_selected \
						[66 67 67] \
						[54 57 57]
		endmacro

	; macro for the color of track labels, with tweaked custom color inheritance if a custom color is too dark
		; if record: red
		; if selected: white
		; if valid color:
		; 	if luminosity < 120: brighten
		; 	use default
		macro track_label_color element
			set element \
				?recarm [255 100 0] \
				?track_selected [255 255 255] \
				?trackcolor_valid \
					luma{0}<120 + custom_col [80 80 80] \
						custom_col \
					[168 172 172]
		endmacro

; set 10 values to a scalar name
	macro paramPair scalar Idx n1 n2 n3 n4 n5 n6 n7 n8 n9 n10
		set scalar param##Idx<=1 n1 param##Idx==2 n2 param##Idx==3 n3 param##Idx==4 n4 param##Idx==5 n5 param##Idx==6 n6 param##Idx==7 n7 param##Idx==8 n8 param##Idx==9 n9 param##Idx>=10 n10
	endmacro

; Theme variables and parameters
	define_parameter 'defaultV6' 'defaultV6_version' 1

	;           description             val min max idx
	indexParams 'A_mcp_indent'          4   1   7   1
	indexParams 'A_tcp_indent'          5   1   7   2
	indexParams 'A_tcp_vol_size'        1   1   7   3
	indexParams 'A_tcp_MeterSize'       3   1   7   4
	indexParams 'A_tcp_Record_Arm'      0   0   15  5
	indexParams 'A_tcp_Monitor'         4   0   15  6
	indexParams 'A_tcp_Track_Name'      0   0   15  7
	indexParams 'A_tcp_Volume'          0   0   15  8
	indexParams 'A_tcp_Routing'         1   0   15  9
	indexParams 'A_tcp_Effects'         0   0   15  10
	indexParams 'A_tcp_Envelope'        0   0   15  11
	indexParams 'A_tcp_Pan_&_Width'     1   0   15  12
	indexParams 'A_tcp_Record_Mode'     4   0   15  13
	indexParams 'A_tcp_Input'           4   0   15  14
	indexParams 'A_tcp_Values'          2   0   15  15
	indexParams 'A_tcp_Meter_Values'    4   0   15  16
	indexParams 'A_tcp_MeterLoc'        2   1   3   17
	indexParams 'A_tcp_LabelSize'       6   1   7   18
	indexParams 'A_tcp_LabelMeasure'    100 1   200 19
	indexParams 'A_tcp_InputSize'       5   1   7   20
	indexParams 'A_envcp_labelSize'     6   1   7   21
	indexParams 'A_envcp_LabelMeasure'  100 1   200 22
	indexParams 'A_envcp_fader_size'    1   1   7   23
	indexParams 'A_envcp_folder_indent' 1   0   1   24
	indexParams 'A_mcp_Sidebar'         0   1   5   25
	indexParams 'A_mcp_Narrow'          0   1   5   26
	indexParams 'A_mcp_Meter_Expansion' 3   1   5   27
	indexParams 'A_mcp_Labels'          3   1   5   28
	indexParams 'A_mcp_meterExpSize'    3   1   4   29
	indexParams 'A_mcp_border'          1   1   5   30

	indexParams 'B_tcp_vol_size'        5   1   7   31
	indexParams 'B_tcp_MeterSize'       3   1   7   32
	indexParams 'B_tcp_Record_Arm'      0   0   15  33
	indexParams 'B_tcp_Monitor'         0   0   15  34
	indexParams 'B_tcp_Track_Name'      0   0   15  35
	indexParams 'B_tcp_Volume'          0   0   15  36
	indexParams 'B_tcp_Routing'         0   0   15  37
	indexParams 'B_tcp_Effects'         0   0   15  38
	indexParams 'B_tcp_Envelope'        0   0   15  39
	indexParams 'B_tcp_Pan_&_Width'     0   0   15  40
	indexParams 'B_tcp_Record_Mode'     0   0   15  41
	indexParams 'B_tcp_Input'           0   0   15  42
	indexParams 'B_tcp_Values'          0   0   15  43
	indexParams 'B_tcp_Meter_Values'    0   0   15  44
	indexParams 'B_tcp_MeterLoc'        2   1   3   45
	indexParams 'B_tcp_InputSize'       6   1   7   46
	indexParams 'B_tcp_LabelSize'       5   1   7   47
	indexParams 'B_mcp_Sidebar'         0   1   5   48
	indexParams 'B_mcp_Narrow'          0   1   5   49
	indexParams 'B_mcp_Meter_Expansion' 3   1   5   50
	indexParams 'B_mcp_Labels'          0   1   5   51
	indexParams 'B_mcp_meterExpSize'    4   1   4   52
	indexParams 'B_mcp_border'          5   1   5   53

	indexParams 'C_tcp_vol_size'        1   1   7   54
	indexParams 'C_tcp_MeterSize'       6   1   7   55
	indexParams 'C_tcp_Record_Arm'      0   0   15  56
	indexParams 'C_tcp_Monitor'         4   0   15  57
	indexParams 'C_tcp_Track_Name'      0   0   15  58
	indexParams 'C_tcp_Volume'          0   0   15  59
	indexParams 'C_tcp_Routing'         1   0   15  60
	indexParams 'C_tcp_Effects'         1   0   15  61
	indexParams 'C_tcp_Envelope'        1   0   15  62
	indexParams 'C_tcp_Pan_&_Width'     1   0   15  63
	indexParams 'C_tcp_Record_Mode'     4   0   15  64
	indexParams 'C_tcp_Input'           0   0   15  65
	indexParams 'C_tcp_Values'          2   0   15  66
	indexParams 'C_tcp_Meter_Values'    0   0   15  67
	indexParams 'C_tcp_MeterLoc'        1   1   3   68
	indexParams 'C_tcp_InputSize'       4   1   7   69
	indexParams 'C_tcp_LabelSize'       5   1   7   70
	indexParams 'C_mcp_Sidebar'         1   1   5   71
	indexParams 'C_mcp_Narrow'          2   1   5   72
	indexParams 'C_mcp_Meter_Expansion' 3   1   5   73
	indexParams 'C_mcp_Labels'          1   1   5   74
	indexParams 'C_mcp_meterExpSize'    1   1   4   75
	indexParams 'C_mcp_border'          1   1   5   76

	indexParams 'A_trans_rate_size'     1   1   7   77
	indexParams 'A_mcp_control_align'   2   1   2   78
	indexParams 'A_tcp_control_align'   1   1   2   79

; global color and other custom parameters
	def gl_pan_color     trackpanmode<=5 [0 0 0 120]       [84 63 63]
	def gl_width_color   trackpanmode=5  [255 255 255 210] [63 84 63]
	; Switch swaper ?
	def gl_fader_swap    trackpanmode==6 [0]               [1]
	;text_over_custom val_color 															; ERADICATE THIS

; Track control panels
	clear tcp.*

	front tcp.recarm tcp.label tcp.volume tcp.pan_group tcp.solo tcp.mute tcp.phase tcp.width tcp.foldercomp tcp.folder

	; Param19 is A_tcp_LabelMeasure'
	set tcpLabelAutoMeasured param19

	; Set parameters for different elements
		;         name              id min x  x  x   x   x   max
		paramPair tcp_meter_size     4  4   10 24 40  100 180 320
		paramPair tcp_meter_position      17 0   1  2
		paramPair tcp_VolSize       3  20  40 70 100 130 160 190
		paramPair tcp_InSize        20 49  64 80 100 130 190 240
		paramPair tcp_LabelPair     18 0   20 50 80  110 140 170

	compute_tcp_sections
	resetHides

	; Hide some elements
	;doHideLogic tcp.recarm   5
	;doHideLogic tcp.recmon   6
	;doHideLogic tcp.label    7
	;doHideLogic tcp.volume   8
	;doHideLogic tcp.io       9
	;doHideLogic fx_group     10
	;doHideLogic tcp.env      11
	;doHideLogic pan_group    12
	;doHideLogic tcp.recmode  13
	;doHideLogic input_group  14
	doHideLogic values       15
	;doHideLogic meter_values 16

	; Element ordering in the tcp
		;    element     size
		then tcp.recarm  20
		then tcp.recmon  15
		then tcp.label   tcp_label_size
		then tcp.volume  20
		then tcp.pan     20
		then tcp.width   20
		then tcp.mute    20
		then tcp.solo    20
		then tcp.phase   20
		then tcp.io      34
		then fx_group    36
		then input_group tcp_InSize
		then tcp.env     41
		then tcp.recmode 39

	; Draw the layout
	draw_tcp

	; Custom layouts
	;;Layout "A"

		;;	compute_tcp_sections
		;;	resetHides

		;;	doHideLogic tcp.recarm   5
		;;	doHideLogic tcp.recmon   6
		;;	doHideLogic tcp.label    7
		;;	doHideLogic tcp.volume   8
		;;	doHideLogic tcp.io       9
		;;	doHideLogic fx_group     10
		;;	doHideLogic tcp.env      11
		;;	doHideLogic pan_group    12
		;;	doHideLogic tcp.recmode  13
		;;	doHideLogic input_group  14
		;;	doHideLogic values       15
		;;	doHideLogic meter_values 16

		;;	then tcp.recarm  20            0
		;;	then tcp.recmon  15            0
		;;	then tcp.label   tcp_label_size 0
		;;	then tcp.volume  tcp_VolSize   0
		;;	then pan_group   tcp_PanSize   1
		;;	then fx_group    36            1
		;;	then tcp.io      34            1
		;;	then tcp.env     41            1
		;;	then tcp.recmode 39            1
		;;	then input_group tcp_InSize    1

		;;	set tcp.label  .
		;;EndLayout

; Master Track Control Panel

	paramPair 	tcp_meter_size 					4 4 10 22 40 80 160 320
	paramPair 	tcp_meter_position 					17 0 1 2

	calcMasterTcpSecs
	resetHides

 ;    element          size
 then master.tcp.label 50
 then master.tcp.io    34
 then master_fx_group  36
 then master.tcp.env   41
 then master_pan_group mTcp_PanSize
 then master.tcp.mono  50
 then master.tcp.solo  20
 then master.tcp.mute  20

	draw_master_tcp 1

; Envelope Control Panels
	paramPair 	EnvcpLabelSize 					21 0 20 50 80 110 140 170
	paramPair 	EnvcpVolSize 					23 20 40 70 100 130 160 190
	set EnvLabelAutoMeasured 					param22
	set EnvFolderIndent							param24

	clear envcp.*
	front		envcp.fader

	macro calcEnvSecs 

		set envcp.size							 [300 100]
		set tcp_row_height 							 20
		set envcp_padding						 [7 7]
		set values_w							 60
		set envcp_squash_height 					+ + 20 envcp_padding{1} envcp_padding{1}
		set valuesFlipH								+ + envcp_squash_height 13 envcp_padding{1}
		set h_less_border							- h 1
		set envcp_padding							h_less_border{0}<envcp_squash_height{0} + [envcp_padding] * [0 1] / - h_less_border{0} tcp_row_height 2
		set envLabelMin							 30
		set Envcp_labelSize 						EnvcpLabelSize{0}==0 EnvLabelAutoMeasured{0}<envLabelMin{0} envLabelMin{0} + EnvLabelAutoMeasured{0} 10 EnvcpLabelSize
		set this_envcp_indent						+ ?EnvFolderIndent{0} * tcp_folder_indent{0} folderdepth{0} [0] [-3 0 -6] ; subtracting 3px to match the lack of visible borders
		set main_section								- + * [1 0 -1] this_envcp_indent [0 0 w h] h<valuesFlipH{0} [0 0 values_w 0] + [0 0 0 13] [0 0 0 envcp_padding{1}]
		set envcpNullElement						+ + [main_section] [envcp_padding envcp_padding] [0 0 0 20]
		set previous_element 						envcpNullElement		; Let's start at the very beginning. A very good place to start.
		set addCont									envcp_type==4 [30 1] [0 0]
	endMacro

	calcEnvSecs 

	macro envThen element width use_padding
		set s_width				 width 

		set prev_end 			+ [previous_element] [previous_element{2}]									; find the end of the previous element
		set element 			[prev_end previous_element s_width tcp_row_height]									; ...and place the element there

		; x-axis
		set element 			?use_padding + [envcp_padding] 												; if x-padding is required, add it
		set this_end			- + + [element] [element{2}] [envcp_padding] [main_section]						; okay, and what does that make the x-end of this element, realtive to main_section?

		; y-axis
		set next_row			+ [0 element] [0 previous_element{3}] 										; find the y of the next row
		set element 			this_end{0}>main_section{2} + [main_section next_row element element] envcp_padding	; move it to the next row
		set this_end			- + + [element] [element{2}] [envcp_padding] [main_section]						; recalculate this_end, now that the element is on a new row
		set element				this_end{0}>main_section{2} [. . 0 .]											; ... and cull if there's still not enough main_section width to fit
		set this_y_end			+ + element{1} element{3} envcp_padding{1}									; find its bottom
		set element				this_y_end{0}>main_section{3} [0] !previous_element{1} [0] .					; cull if there's not enough height to fit, or if previous_element was culled
		set main_section_last_visible_element 		element{3}>0 this_y_end{0} .

		; values readout control
		set valuesRoom			- - main_section{3} this_y_end{0} envcp_padding{1}								; is the remaining height after this element enough for the values to fit?
		set previous_element element
	endmacro

	;    element        		size  	padding?
	envThen envcp.arm  			20 			0
	envThen envcp.bypass  		15 			0
	envThen envcp.label   envcp_labelSize 	0
	envThen envcp.fader    EnvcpVolSize 	0
	envThen envcp.mod 		addCont{0}  addCont{1}
	envThen envcp.learn		addCont{0}  addCont{1}
	envThen envcp.hide 			36 			1

	macro drawEnvcp 
		set envcp.label.color      					[184 184 184]
			set envcp.label.margin     			 [2 0 2 0 0]
			set envcp.label.font					[1]
		set envcp.value								[0 0 0 4]
			set envcp.value.font       				[1]
			set envcp.value.color      				[92 184 169]
			set envcp.value.margin     				* [0 0 1 0 1] [0 0 7 0 1]
		set envcp.fader.color      					[54 217 190]
			set env_fader_w							21
			set envcp.fader.fadermode         		envcp.fader{w}>env_fader_w{0} [0] [1]
	endMacro

	drawEnvcp

	Layout "A"
		set envcp.label  .
		drawEnvcp

; Mixer
	macro doModeLogic variable paramIdx
		set variable param##paramIdx##&1 ?track_selected 1 0
		set variable param##paramIdx##&2 !track_selected 1 variable
		set variable param##paramIdx##&4 ?recarm 1 variable
		set variable param##paramIdx##&8 !recarm 1 variable
	endmacro


	set hide_inputFX				[400] 	; height below which input effects is hidden.
	set hide_input              	[350] 	; height below which input dropdown is hidden.
	set hide_pan_labels          	[320] 	; height below which pan labels are hidden.
	set hide_pan					[260] 	; height below which pan controls are hidden.
	set hide_volume_label        	[250] 	; height below which volume label is hidden.
	set extmixer_w					[86] 	; width of the extmixer when set as a sidebar

	  ; sidebar (pushes other secs right)
	  ; fx section (background is baked into mcp_bg)
	  ; pan section
	  ; input section (show/hide inputFX on resize / recarm, with user override)
	  ; stretch section (recarm pokes above)

	paramPair mcp_indent 			1 0 5 10 15 20 25 30
	paramPair mcp_control_align 	78 0 1

	doModeLogic sidebarMode 	25
	doModeLogic narrowMode 		26
	doModeLogic meterExpMode 	27
	doModeLogic labelsMode 		28
	paramPair mcp_meterExp 		29 0 2 4 8
	paramPair mcp_border 		30 0 1 2 3 4
	drawMcp 1

	Layout "A"
		set mcp.label  .
		drawMcp 1

		Layout "150%_A" "150"
			set mcp.label  .
			drawMcp 1.5
			; ---- scaling error cleanup ----
			set mcp.volume.label 		+ mcp.volume.label [-1]
			; -------------------------------
		EndLayout

		Layout "200%_A" "200"
			set mcp.label  .
			drawMcp 2.0
		EndLayout

	EndLayout

	Layout "B"
		set sidebarMode 			0
		set narrowMode 				0
		set meterExpMode 			0
		set labelsMode 				0
		doModeLogic sidebarMode 	48
		doModeLogic narrowMode 		49
		doModeLogic meterExpMode 	50
		doModeLogic labelsMode 		51
		paramPair mcp_meterExp 		52 0 2 4 8
		paramPair mcp_border 		53 0 1 2 3 4
		drawMcp 1

		Layout "150%_B" "150"
			set mcp.label  .
			drawMcp 1.5
			; ---- scaling error cleanup ----
			set mcp.volume.label 		+ mcp.volume.label [-1]
		EndLayout

		Layout "200%_B" "200"
			set mcp.label  .
			drawMcp 2.0
		EndLayout

	EndLayout

	Layout "C"
		set sidebarMode 			0
		set narrowMode 				0
		set meterExpMode 			0
		set labelsMode 				0
		doModeLogic sidebarMode 	71
		doModeLogic narrowMode 		72
		doModeLogic meterExpMode 	73
		doModeLogic labelsMode 		74
		paramPair mcp_meterExp 		75 0 2 4 8
		paramPair mcp_border 		76 0 1 2 3 4
		drawMcp 1


		Layout "150%_C" "150"
			set mcp.label  .
			drawMcp 1.5
			; ---- scaling error cleanup ----
			set mcp.volume.label 		+ mcp.volume.label [-1]
		EndLayout

		Layout "200%_C" "200"
			set mcp.label  .
			drawMcp 2.0
		EndLayout

	EndLayout

; Master Mixer
	  ; --------------- User adjustable values. Edit without fear. -----------------

	set hide_inputFX				[400] ; height below which input effects is hidden.
	set hide_pan_labels          	[320] ; height below which pan labels are hidden.
	set hide_pan					[260] ; height below which pan controls are hidden.
	set hide_volume_label        	[200] ; height below which volume label is hidden.

	  ; ------- End of user adjustable values. From here on may be dragons. ---------

	macro drawMasterMcp
		clear master.mcp.*
		front                							master.mcp.menubutton master.mcp.io master.mcp.env master.mcp.mute master.mcp.solo
		set master.mcp.size         					+ [125 370] [0 0 0 mcp.size]
		set hide_pan_sm 							 hide_pan
		set hide_pan_labels_sm						 hide_pan_labels
		set fx_sec								 		+ [0 0 master.mcp.size{0}] [0 0 0 27]
		set pan_sec 						     		+ [0 fx_sec{3} master.mcp.size{0}] h<hide_pan_labels_sm{0} h<hide_pan_sm{0} [0 0 0 6] [0 0 0 28] [0 0 0 48]
		set bot_sec								 		+ [0 h master.mcp.size{0}] [0 -23 0 23]
		set stretch_sec_start					 		+ fx_sec{3} pan_sec{3}
		set stretch_sec_height					 		- - - h fx_sec{3} pan_sec{3} bot_sec{3}
		set stretch_sec 						 		[0 stretch_sec_start{0} master.mcp.size{0} stretch_sec_height{0}]
		set padding_reduction_h						 [300 200]
		set padding 							 	 stretch_sec_height{0}<padding_reduction_h{0} stretch_sec_height{0}<padding_reduction_h{1} [0 2] [0 3] [0 4]
		set master.mcp.fx                               [7 7 82 20]
		set master.mcp.fxbyp                            [89 7 29 20]
		set master.mcp.pan   							+ [0 pan_sec] h<hide_pan_sm{0} [0]  	trackpanmode==6 	h<hide_pan_labels_sm{0} [7 5 67 9] [7 15 67 9] \
																									trackpanmode>=4		h<hide_pan_labels_sm{0} [20 4 20 20] [20 7 20 20] \
																														h<hide_pan_labels_sm{0} [31 4 20 20] [31 7 20 20]
		  set master.mcp.pan.fadermode              	gl_fader_swap
		  set master.mcp.pan.color                  	gl_pan_color
		  set master.mcp.pan.label                  	h<hide_pan_labels_sm{x} [0] + [0 master.mcp.pan] trackpanmode>=4 trackpanmode==6 [23 -11 35 9] [6 25 35 10] [23 25 35 10]
		  set master.mcp.pan.label.color				[140 140 140]
		  set master.mcp.pan.label.margin           	[0 0 0 0 0.5]
		  set master.mcp.pan.label.font					[1]
		set master.mcp.width  							+ [0 pan_sec] h<hide_pan_sm{0} [0]  	trackpanmode==6 	h<hide_pan_labels_sm{0} [7 13 67 9] [7 23 67 9] \
																									trackpanmode>=4		h<hide_pan_labels_sm{0} [48 4 20 20] [48 7 20 20] [0]
		  set master.mcp.width.fadermode            	gl_fader_swap
		  set master.mcp.width.color                	gl_width_color
		  set master.mcp.width.label                	h<hide_pan_labels_sm{x} [0] + [0 master.mcp.width] trackpanmode>=4 trackpanmode==6 [23 11 35 9] [41 25 35 10] [0]
		  set master.mcp.width.label.color				[140 140 140]
		  set master.mcp.width.label.margin         	[0 0 0 0 0.5]
		  set master.mcp.width.label.font				[1]
		set master.mcp.mono                             + [0 pan_sec] h<hide_pan_labels_sm{0} h<hide_pan_sm{0} [0] [93 4 25 22] [93 8 25 33]
		set master.mcp.volume.label                     h<hide_volume_label{0} [0 0 0 0] + [0 stretch_sec] [1 0 89 23]
		  set master.mcp.volume                         - + + [69 0 21] [0 stretch_sec 0 stretch_sec] [0 master.mcp.volume.label{3}] [0 0 0 master.mcp.volume.label{3}]
		  set master.mcp.volume.label.color             master.mcp.volume.label{h}>2 [100 100 100] [38 38 38]
		  set master.mcp.volume.label.margin            + [0 0 0 0 0.5] [0 4]
		  set master.mcp.volume.label.font				[1]
		set master.mcp.meter                            + [0 master.mcp.volume 0 master.mcp.volume] [4 0 59 -6]
		  set master.mcp.meter.vu.div                   [1]
		  set master.mcp.meter.vu.rmsdiv                [2]
		  set master.mcp.meter.readout.color            [255 255 255 200 0 0 0 0]
		  set master.mcp.meter.rmsreadout.color         [255 255 255 255 0 0 0 0]
		  set master.mcp.meter.scale.color.lit.bottom   [0 0 0 200 0 0 0 0]
		  set master.mcp.meter.scale.color.lit.top      [0 0 0 200 0 0 0 0]
		  set master.mcp.meter.scale.color.unlit.bottom [255 255 255 120 0 0 0 0]
		  set master.mcp.meter.scale.color.unlit.top    [255 255 255 120 0 0 0 0]
		set master.mcp.label                            bot_sec
		  set master.mcp.label.color                    [184 184 184]
		  set master.mcp.label.margin                   + [20 1] [0 0 0 0 0.5]
		  set master.mcp.label.font						[3]
		set master.mcp.mute                             + [0 stretch_sec] [95 6 21 20]
		set master.mcp.solo                             + + [0 padding] [master.mcp.mute master.mcp.mute] [0 21 21 20]
		set master_mcp_env_hide_h					 141
		set master.mcp.env                              stretch_sec_height{0}<master_mcp_env_hide_h{0} [0] + + [0 stretch_sec] [0 stretch_sec{3}] [95 -37 21 30]
		set master_mcp_io_hide_h					 106
		set master.mcp.io                               stretch_sec_height{0}<master_mcp_io_hide_h{0} [0] + + [0 padding] [master.mcp.solo master.mcp.solo] [0 23 23 30]
		set master.mcp.menubutton                       + [0 2 20 20] [bot_sec bot_sec]
		set master.mcp.extmixer.mode                    [0]
			set master.mcp.fxlist.font                  [1 16]
			set master.mcp.fxlist.margin                mcp.fxlist.margin 
			set master.mcp.sendlist.font                [1 16]
			set master.mcp.sendlist.margin              mcp.sendlist.margin
			set master.mcp.fxparm.font                  [1 24 0 0 -1]
			set master.mcp.fxparm.margin                mcp.fxparm.margin
	endmacro
	drawMasterMcp

; Transport
	; hidden from editor, can remove everything related to it
